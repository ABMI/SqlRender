% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Using SqlRender},
  pdfauthor={Martijn J. Schuemie},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}

\title{Using SqlRender}
\author{Martijn J. Schuemie}
\date{2020-03-17}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{2}
\tableofcontents
}
\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

This vignette describes how one could use the SqlRender R package.

\hypertarget{sql-parameterization}{%
\section{SQL parameterization}\label{sql-parameterization}}

One of the main functions of the package is to support parameterization
of SQL. Often, small variations of SQL need to be generated based on
some parameters. SqlRender offers a simple markup syntax inside the SQL
code to allow parameterization. Rendering the SQL based on parameter
values is done using the \texttt{render()} function.

\hypertarget{substituting-parameter-values}{%
\subsection{Substituting parameter
values}\label{substituting-parameter-values}}

The \texttt{@} character can be used to indicate parameter names that
need to be exchange for actual parameter values when rendering. In the
following example, a variable called \texttt{a} is mentioned in the SQL.
In the call to the render function the value of this parameter is
defined:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sql <-}\StringTok{ "SELECT * FROM table WHERE id = @a;"}
\KeywordTok{render}\NormalTok{(sql, }\DataTypeTok{a =} \DecValTok{123}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
#> [1] "SELECT * FROM table WHERE id = 123;"
\end{verbatim}

Note that, unlike the parameterization offered by most database
management systems, it is just as easy to parameterize table or field
names as values:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sql <-}\StringTok{ "SELECT * FROM @x WHERE id = @a;"}
\KeywordTok{render}\NormalTok{(sql, }\DataTypeTok{x =} \StringTok{"my_table"}\NormalTok{, }\DataTypeTok{a =} \DecValTok{123}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
#> [1] "SELECT * FROM my_table WHERE id = 123;"
\end{verbatim}

The parameter values can be numbers, strings, booleans, as well as
vectors, which are converted to comma-delimited lists:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sql <-}\StringTok{ "SELECT * FROM table WHERE id IN (@a);"}
\KeywordTok{render}\NormalTok{(sql, }\DataTypeTok{a =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
#> [1] "SELECT * FROM table WHERE id IN (1,2,3);"
\end{verbatim}

\hypertarget{default-parameter-values}{%
\subsection{Default parameter values}\label{default-parameter-values}}

For some or all parameters, it might make sense to define default values
that will be used unless the user specifies another value. This can be
done using the \texttt{\{DEFAULT\ @parameter\ =\ value\}} syntax:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sql <-}\StringTok{ "\{DEFAULT @a = 1\} SELECT * FROM table WHERE id = @a;"}
\KeywordTok{render}\NormalTok{(sql)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
#> [1] "SELECT * FROM table WHERE id = 1;"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{render}\NormalTok{(sql, }\DataTypeTok{a =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
#> [1] "SELECT * FROM table WHERE id = 2;"
\end{verbatim}

Defaults for multiple variables can be defined:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sql <-}\StringTok{ "\{DEFAULT @a = 1\} \{DEFAULT @x = 'my_table'\} SELECT * FROM @x WHERE id = @a;"}
\KeywordTok{render}\NormalTok{(sql)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
#> [1] "SELECT * FROM my_table WHERE id = 1;"
\end{verbatim}

\hypertarget{if-then-else}{%
\subsection{If-then-else}\label{if-then-else}}

Sometimes blocks of codes need to be turned on or off based on the
values of one or more parameters. This is done using the
\texttt{\{Condition\}\ ?\ \{if\ true\}\ :\ \{if\ false\}} syntax. If the
\emph{condition} evaluates to true or 1, the \emph{if true} block is
used, else the \emph{if false} block is shown (if present).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sql <-}\StringTok{ "SELECT * FROM table \{@x\} ? \{WHERE id = 1\}"}
\KeywordTok{render}\NormalTok{(sql, }\DataTypeTok{x =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
#> [1] "SELECT * FROM table "
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{render}\NormalTok{(sql, }\DataTypeTok{x =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
#> [1] "SELECT * FROM table WHERE id = 1"
\end{verbatim}

Simple comparisons are also supported:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sql <-}\StringTok{ "SELECT * FROM table \{@x == 1\} ? \{WHERE id = 1\};"}
\KeywordTok{render}\NormalTok{(sql, }\DataTypeTok{x =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
#> [1] "SELECT * FROM table WHERE id = 1;"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{render}\NormalTok{(sql, }\DataTypeTok{x =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
#> [1] "SELECT * FROM table ;"
\end{verbatim}

As well as the \texttt{IN} operator:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sql <-}\StringTok{ "SELECT * FROM table \{@x IN (1,2,3)\} ? \{WHERE id = 1\};"}
\KeywordTok{render}\NormalTok{(sql, }\DataTypeTok{x =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
#> [1] "SELECT * FROM table WHERE id = 1;"
\end{verbatim}

Clauses can combined with boolean operators:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sql <-}\StringTok{ "SELECT * FROM table \{@x IN (1,2,3) | @y != 3\} ? \{WHERE id = @x AND value = @y\};"}
\KeywordTok{render}\NormalTok{(sql, }\DataTypeTok{x =} \DecValTok{4}\NormalTok{, }\DataTypeTok{y =} \DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
#> [1] "SELECT * FROM table WHERE id = 4 AND value = 4;"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sql <-}\StringTok{ "SELECT * FROM table \{(@x == 1 | @x == 3) & @y != 3\} ? \{WHERE id = @x AND val = @y\};"}
\KeywordTok{render}\NormalTok{(sql, }\DataTypeTok{x =} \DecValTok{3}\NormalTok{, }\DataTypeTok{y =} \DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
#> [1] "SELECT * FROM table WHERE id = 3 AND val = 4;"
\end{verbatim}

\hypertarget{translation-to-other-sql-dialects}{%
\section{Translation to other SQL
dialects}\label{translation-to-other-sql-dialects}}

SQL for one platform (e.g.~Microsoft SQL Server) will not always execute
on other platforms (e.g.~Oracle). The \texttt{translate()} function can
be used to translate between different dialects, but there are some
limitations.

A first limitation is that \textbf{the starting dialect has to be SQL
Server}. The reason for this is that this dialect is in general the most
specific. For example, the number of days between two dates in SQL
Server has to be computed using the DATEDIFF function:
\texttt{DATEDIFF(dd,a,b)}. In other languages one can simply subtract
the two dates: \texttt{b-a}. Since you'd need to know a and b are dates,
it is not possible to go from other languages to SQL Server, only the
other way around.

A second limitation is that currently only these dialects are supported
as targets: \textbf{Oracle}, \textbf{PostgreSQL}, \textbf{Microsoft PDW
(Parallel Data Warehouse)}, \textbf{Impala}, \textbf{Netezza},
\textbf{Google BigQuery}, \textbf{Amazon Redhift}, and \textbf{SQLite}.

A third limitation is that only a limited set of translation rules have
currently been implemented, although adding them to the
\href{https://github.com/OHDSI/SqlRender/blob/master/inst/csv/replacementPatterns.csv}{list}
should not be hard.

A last limitation is that not all functions supported in one dialect
have an equivalent in other dialects.

Below an example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sql <-}\StringTok{ "SELECT DATEDIFF(dd,a,b) FROM table; "}
\KeywordTok{translate}\NormalTok{(sql, }\DataTypeTok{targetDialect =} \StringTok{"oracle"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
#> [1] "SELECT (CAST(b AS DATE) - CAST(a AS DATE)) FROM table ; "
\end{verbatim}

The \texttt{targetDialect} parameter can have the following values:

\begin{itemize}
\tightlist
\item
  ``oracle''
\item
  ``postgresql''
\item
  ``pdw''
\item
  ``redshift''
\item
  ``impala''
\item
  ``netezza''
\item
  ``bigquery''
\item
  ``sqlite''
\item
  ``sql server'' (no translation)
\end{itemize}

\hypertarget{functions-and-structures-supported-by-translate}{%
\subsection{Functions and structures supported by
translate}\label{functions-and-structures-supported-by-translate}}

These SQL Server functions have been tested and were found to be
translated correctly to the various dialects:

\begin{longtable}[]{@{}llll@{}}
\caption{Functions supported by translate}\tabularnewline
\toprule
Function & Function & Function & Function\tabularnewline
\midrule
\endfirsthead
\toprule
Function & Function & Function & Function\tabularnewline
\midrule
\endhead
ABS & DATEDIFF & LOG & ROUND\tabularnewline
ACOS & DATEFROMPARTS & LOG10 & ROW\_NUMBER\tabularnewline
ASIN & DATETIMEFROMPARTS & LOWER & RTRIM\tabularnewline
ATAN & DAY & LTRIM & SIN\tabularnewline
AVG & EOMONTH & MAX & SQRT\tabularnewline
CAST & EXP & MIN & SQUARE\tabularnewline
CEILING & FLOOR & MONTH & STDEV\tabularnewline
CHARINDEX & GETDATE & NEWID & SUM\tabularnewline
CONCAT & HASHBYTES* & PI & TAN\tabularnewline
COS & ISNULL & POWER & UPPER\tabularnewline
COUNT & ISNUMERIC & RAND & VAR\tabularnewline
COUNT\_BIG & LEFT & RANK & YEAR\tabularnewline
DATEADD & LEN & RIGHT &\tabularnewline
\bottomrule
\end{longtable}

\begin{itemize}
\tightlist
\item
  Requires special privileges on Oracle. Has no equivalent on SQLite.
\end{itemize}

Similarly, many SQL syntax structures are supported. Here is a
non-exhaustive lists of things that we know will translate well:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM} \KeywordTok{table}\NormalTok{;                                        }\CommentTok{-- Simple selects}

\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM}\NormalTok{ table_1 }\KeywordTok{INNER} \KeywordTok{JOIN}\NormalTok{ table_2 }\KeywordTok{ON}\NormalTok{ a }\OperatorTok{=}\NormalTok{ b;          }\CommentTok{-- Selects with joins }

\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM}\NormalTok{ (}\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM}\NormalTok{ table_1) tmp }\KeywordTok{WHERE}\NormalTok{ a }\OperatorTok{=}\NormalTok{ b;      }\CommentTok{-- Nested queries}

\KeywordTok{SELECT}\NormalTok{ TOP }\DecValTok{10} \OperatorTok{*} \KeywordTok{FROM} \KeywordTok{table}\NormalTok{;                                 }\CommentTok{-- Limiting to top rows}

\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{INTO}\NormalTok{ new_table }\KeywordTok{FROM} \KeywordTok{table}\NormalTok{;                         }\CommentTok{-- Selecting into a new table}

\KeywordTok{CREATE} \KeywordTok{TABLE} \KeywordTok{table}\NormalTok{ (field }\DataTypeTok{INT}\NormalTok{);                             }\CommentTok{-- Creating tables}

\KeywordTok{INSERT} \KeywordTok{INTO}\NormalTok{ other_table (field_1) }\KeywordTok{VALUES}\NormalTok{ (}\DecValTok{1}\NormalTok{);               }\CommentTok{-- Inserting verbatim values           }

\KeywordTok{INSERT} \KeywordTok{INTO}\NormalTok{ other_table (field_1) }\KeywordTok{SELECT} \FunctionTok{value} \KeywordTok{FROM} \KeywordTok{table}\NormalTok{;  }\CommentTok{-- Inserting from SELECT}
  
\KeywordTok{DROP} \KeywordTok{TABLE} \KeywordTok{table}\NormalTok{;                                           }\CommentTok{-- Simple drop commands}

\ControlFlowTok{IF}\NormalTok{ OBJECT_ID(}\StringTok{'ACHILLES_analysis'}\NormalTok{, }\StringTok{'U'}\NormalTok{) }\KeywordTok{IS} \KeywordTok{NOT} \KeywordTok{NULL}          \CommentTok{-- Drop table if it exists}
  \KeywordTok{DROP} \KeywordTok{TABLE}\NormalTok{ ACHILLES_analysis;}
  
\ControlFlowTok{IF}\NormalTok{ OBJECT_ID(}\StringTok{'tempdb..#cohorts'}\NormalTok{, }\StringTok{'U'}\NormalTok{) }\KeywordTok{IS} \KeywordTok{NOT} \KeywordTok{NULL}           \CommentTok{-- Drop temp table if it exists}
  \KeywordTok{DROP} \KeywordTok{TABLE}\NormalTok{ #cohorts;  }

\KeywordTok{WITH}\NormalTok{ cte }\KeywordTok{AS}\NormalTok{ (}\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM} \KeywordTok{table}\NormalTok{) }\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM}\NormalTok{ cte;        }\CommentTok{-- Common table expressions}

\KeywordTok{SELECT} \FunctionTok{ROW_NUMBER}\NormalTok{() }\KeywordTok{OVER}\NormalTok{ (}\KeywordTok{PARTITION} \KeywordTok{BY}\NormalTok{ a }\KeywordTok{ORDER} \KeywordTok{BY}\NormalTok{ b)        }\CommentTok{-- OVER clauses}
  \KeywordTok{AS} \OtherTok{"Row Number"} \KeywordTok{FROM} \KeywordTok{table}\NormalTok{;}
  
\KeywordTok{SELECT} \ControlFlowTok{CASE} \ControlFlowTok{WHEN}\NormalTok{ a}\OperatorTok{=}\DecValTok{1} \ControlFlowTok{THEN}\NormalTok{ a }\ControlFlowTok{ELSE} \DecValTok{0} \ControlFlowTok{END} \KeywordTok{AS} \FunctionTok{value} \KeywordTok{FROM} \KeywordTok{table}\NormalTok{; }\CommentTok{-- CASE WHEN clauses}

\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM}\NormalTok{ a }\KeywordTok{UNION} \KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM}\NormalTok{ b                       }\CommentTok{-- UNIONs}

\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM}\NormalTok{ a }\KeywordTok{INTERSECT} \KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM}\NormalTok{ b                   }\CommentTok{-- INTERSECTIONs}

\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM}\NormalTok{ a }\KeywordTok{EXCEPT} \KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM}\NormalTok{ b                      }\CommentTok{-- EXCEPT}
\end{Highlighting}
\end{Shaded}

\hypertarget{string-concatenation}{%
\subsection{String concatenation}\label{string-concatenation}}

String concatenation is one area where SQL Server is less specific than
other dialects. In SQL Server, one would write
\texttt{SELECT\ first\_name\ +\ \textquotesingle{}\ \textquotesingle{}\ +\ last\_name\ AS\ full\_name\ FROM\ table},
but this should be
\texttt{SELECT\ first\_name\ \textbar{}\textbar{}\ \textquotesingle{}\ \textquotesingle{}\ \textbar{}\textbar{}\ last\_name\ AS\ full\_name\ FROM\ table}
in PostgreSQL and Oracle. SqlRender tries to guess when values that are
being concatenated are strings. In the example above, because we have an
explicit string (the space surrounded by single quotation marks), the
translation will be correct. However, if the query had been
\texttt{SELECT\ first\_name\ +\ last\_name\ AS\ full\_name\ FROM\ table},
SqlRender would have had no clue the two fields were strings, and would
incorrectly leave the plus sign. Another clue that a value is a string
is an explicit cast to VARCHAR, so
\texttt{SELECT\ last\_name\ +\ CAST(age\ AS\ VARCHAR(3))\ AS\ full\_name\ FROM\ table}
would also be translated correctly. To avoid ambiguity altogether, it is
probable best to use the \texttt{CONCAT()} function to concatenate two
or more strings.

\hypertarget{table-aliases-and-the-as-keyword}{%
\subsection{Table aliases and the AS
keyword}\label{table-aliases-and-the-as-keyword}}

Many SQL dialects allow the use of the \texttt{AS} keyword when defining
a table alias, but will also work fine without the keyword. For example,
both these SQL statements are fine for SQL Server, PostgreSQL, RedShift,
etc.:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- Using AS keyword}
\KeywordTok{SELECT} \OperatorTok{*} 
\KeywordTok{FROM}\NormalTok{ my_table }\KeywordTok{AS}\NormalTok{ table_1}
\KeywordTok{INNER} \KeywordTok{JOIN}\NormalTok{ (}
  \KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM}\NormalTok{ other_table}
\NormalTok{) }\KeywordTok{AS}\NormalTok{ table_2}
\KeywordTok{ON}\NormalTok{ table_1.person_id }\OperatorTok{=}\NormalTok{ table_2.person_id;}

\CommentTok{-- Not using AS keyword}
\KeywordTok{SELECT} \OperatorTok{*} 
\KeywordTok{FROM}\NormalTok{ my_table table_1}
\KeywordTok{INNER} \KeywordTok{JOIN}\NormalTok{ (}
  \KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM}\NormalTok{ other_table}
\NormalTok{) table_2}
\KeywordTok{ON}\NormalTok{ table_1.person_id }\OperatorTok{=}\NormalTok{ table_2.person_id;}
\end{Highlighting}
\end{Shaded}

However, Oracle will throw an error when the \texttt{AS} keyword is
used. In the above example, the first query will fail. It is therefore
recommended to not use the \texttt{AS} keyword when aliasing tables.
(Note: we can't make SqlRender handle this, because it can't easily
distinguish between table aliases where Oracle doesn't allow \texttt{AS}
to be used, and field aliases, where Oracle requires \texttt{AS} to be
used.)

\hypertarget{temp-tables}{%
\subsection{Temp tables}\label{temp-tables}}

Temp tables can be very useful to store intermediate results, and when
used correctly can be used to dramatically improve performance of
queries. In Postgres, PDW, RedShift and SQL Server temp tables have very
nice properties: they're only visible to the current user, are
automatically dropped when the session ends, and can be created even
when the user has no write access. Unfortunately, in Oracle temp tables
are basically permanent tables, with the only difference that the data
inside the table is only visible to the current user. This is why, in
Oracle, SqlRender will try to emulate temp tables by

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Adding a random string to the table name so tables from different
  users will not conflict.
\item
  Allowing the user to specify the schema where the temp tables will be
  created.
\end{enumerate}

For example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sql <-}\StringTok{ "SELECT * FROM #children;"}
\KeywordTok{translate}\NormalTok{(sql, }\DataTypeTok{targetDialect =} \StringTok{"oracle"}\NormalTok{, }\DataTypeTok{oracleTempSchema =} \StringTok{"temp_schema"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
#> [1] "SELECT * FROM temp_schema.sgpsye25children ;"
\end{verbatim}

Note that the user will need to have write privileges on
\texttt{temp\_schema}.

Also note that because Oracle has a limit on table names of 30
characters, \textbf{temp table names are only allowed to be at most 22
characters long} because else the name will become too long after
appending the session ID.

Furthermore, remember that temp tables are not automatically dropped on
Oracle, so you will need to explicitly \texttt{TRUNCATE} and
\texttt{DROP} all temp tables once you're done with them to prevent
orphan tables accumulating in the Oracle temp schema.

If possible, try to avoid using temp tables altogether. Sometimes one
could use Common Table Expressions (CTEs) when one would normally use a
temp table. For example, instead of

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{INTO}\NormalTok{ #children }\KeywordTok{FROM}\NormalTok{ person }\KeywordTok{WHERE}\NormalTok{ year_of_birth }\OperatorTok{>} \DecValTok{2000}\NormalTok{;}
\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM}\NormalTok{ #children }\KeywordTok{WHERE}\NormalTok{ gender }\OperatorTok{=} \DecValTok{8507}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

you could use

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{WITH}\NormalTok{ children }\KeywordTok{AS}\NormalTok{ (}\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM}\NormalTok{ person }\KeywordTok{WHERE}\NormalTok{ year_of_birth }\OperatorTok{>} \DecValTok{2000}\NormalTok{)}
\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM}\NormalTok{ children }\KeywordTok{WHERE}\NormalTok{ gender }\OperatorTok{=} \DecValTok{8507}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

\hypertarget{implicit-casts}{%
\subsection{Implicit casts}\label{implicit-casts}}

One of the few points where SQL Server is less explicit than other
dialects is that it allows implicit casts. For example, this code will
work on SQL Server:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{CREATE} \KeywordTok{TABLE}\NormalTok{ #temp (txt }\DataTypeTok{VARCHAR}\NormalTok{);}

\KeywordTok{INSERT} \KeywordTok{INTO}\NormalTok{ #temp}
\KeywordTok{SELECT} \StringTok{'1'}\NormalTok{;}

\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM}\NormalTok{ #temp }\KeywordTok{WHERE}\NormalTok{ txt }\OperatorTok{=} \DecValTok{1}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

Even though \texttt{txt} is a VARCHAR field and we are comparing it with
an integer, SQL Server will automatically cast one of the two to the
correct type to allow the comparison. In contrast, other dialects such
as PosgreSQL will throw an error when trying to compare a VARCHAR with
an INT.

You should therefore always make casts explicit. In the above example,
the last statement should be replaced with either

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM}\NormalTok{ #temp }\KeywordTok{WHERE}\NormalTok{ txt }\OperatorTok{=} \FunctionTok{CAST}\NormalTok{(}\DecValTok{1} \KeywordTok{AS} \DataTypeTok{VARCHAR}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

or

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM}\NormalTok{ #temp }\KeywordTok{WHERE} \FunctionTok{CAST}\NormalTok{(txt }\KeywordTok{AS} \DataTypeTok{INT}\NormalTok{) }\OperatorTok{=} \DecValTok{1}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

\hypertarget{case-sensitivity-in-string-comparisons}{%
\subsection{Case sensitivity in string
comparisons}\label{case-sensitivity-in-string-comparisons}}

Some DBMS platforms such as SQL Server always perform string comparisons
in a case-insensitive way, while others such as PostgreSQL are always
case sensitive. It is therefore recommended to always assume
case-sensitive comparisons, and to explicitly make comparisons
case-insensitive when unsure about the case. For example, instead of

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM}\NormalTok{ concept }\KeywordTok{WHERE}\NormalTok{ concep_class_id }\OperatorTok{=} \StringTok{'Clinical Finding'}
\end{Highlighting}
\end{Shaded}

it is preferred to use

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM}\NormalTok{ concept }\KeywordTok{WHERE} \FunctionTok{LOWER}\NormalTok{(concep_class_id) }\OperatorTok{=} \StringTok{'clinical finding'}
\end{Highlighting}
\end{Shaded}

\hypertarget{schemas-and-databases}{%
\subsection{Schemas and databases}\label{schemas-and-databases}}

In SQL Server, tables are located in a schema, and schemas reside in a
database. For example, \texttt{cdm\_data.dbo.person} refers to the
\texttt{person} table in the \texttt{dbo} schema in the
\texttt{cdm\_data} database. In other dialects, even though a similar
hierarchy often exists they are used very differently. In SQL Server,
there is typically one schema per database (often called \texttt{dbo}),
and users can easily use data in different databases. On other
platforms, for example in PostgreSQL, it is not possible to use data
across databases in a single session, but there are often many schemas
in a database. In PostgreSQL one could say that the equivalent of SQL
Server's database is the schema.

We therefore recommend concatenating SQL Server's database and schema
into a single parameter, which we typically call
\texttt{@databaseSchema}. For example, we could have the parameterized
SQL

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM}\NormalTok{ @databaseSchema.person}
\end{Highlighting}
\end{Shaded}

where on SQL Server we can include both database and schema names in the
value: \texttt{databaseSchema\ =\ "cdm\_data.dbo"}. On other platforms,
we can use the same code, but now only specify the schema as the
parameter value: \texttt{databaseSchema\ =\ "cdm\_data"}.

The one situation where this will fail is the \texttt{USE} command,
since \texttt{USE\ cdm\_data.dbo;} will throw an error. It is therefore
preferred not to use the \texttt{USE} command, but always specify the
database / schema where a table is located. However, if one wanted to
use it anyway, we recommend creating two variables, one called
\texttt{@database} and the other called \texttt{@databaseSchema}. For
example, for this parameterized SQL:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM}\NormalTok{ @databaseSchema.person;}
\KeywordTok{USE}\NormalTok{ @database;}
\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM}\NormalTok{ person}
\end{Highlighting}
\end{Shaded}

we can set \texttt{database\ =\ "cdm\_data"} and the other called
\texttt{databaseSchema\ =\ "cdm\_data.dbo"}. On platforms other than SQL
Server, the two variables will hold the same value and only on SQL
Server will they be different. Within an R function, it is even possible
to derive one variable from the other, so the user of your function
would need to specify only one value:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{foo <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(databaseSchema, dbms) \{}
\NormalTok{    database <-}\StringTok{ }\KeywordTok{strsplit}\NormalTok{(databaseSchema, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{."}\NormalTok{)[[}\DecValTok{1}\NormalTok{]][}\DecValTok{1}\NormalTok{]}
\NormalTok{    sql <-}\StringTok{ "SELECT * FROM @databaseSchema.person; USE @database; SELECT * FROM person;"}
\NormalTok{    sql <-}\StringTok{ }\KeywordTok{render}\NormalTok{(sql, }\DataTypeTok{databaseSchema =}\NormalTok{ databaseSchema, }\DataTypeTok{database =}\NormalTok{ database)}
\NormalTok{    sql <-}\StringTok{ }\KeywordTok{translate}\NormalTok{(sql, }\DataTypeTok{targetDialect =}\NormalTok{ dbms)}
    \KeywordTok{return}\NormalTok{(sql)}
\NormalTok{\}}
\KeywordTok{foo}\NormalTok{(}\StringTok{"cdm_data.dbo"}\NormalTok{, }\StringTok{"sql server"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
#> [1] "SELECT * FROM cdm_data.dbo.person; USE cdm_data; SELECT * FROM person;"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{foo}\NormalTok{(}\StringTok{"cdm_data"}\NormalTok{, }\StringTok{"postgresql"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
#> [1] "SELECT * FROM cdm_data.person; SET search_path TO cdm_data; SELECT * FROM person;"
\end{verbatim}

\hypertarget{optimization-for-massively-parallel-processing}{%
\subsection{Optimization for massively parallel
processing}\label{optimization-for-massively-parallel-processing}}

Both PDW and RedShift are massively parallel processing platforms,
meaning they consist of many nodes that work together. In such an
environment, significant increases in performance can be achieved by
fine-tuning the SQL for these platforms. Probably most importantly,
developers can specify the way data is distributed over the nodes.
Ideally, data in a node only needs to be combined with data in the same
node. For example, if I have two tables with the field
\texttt{person\_id}, I would like all records with the same person ID to
be on the same node, so a join on \texttt{person\_id} can be performed
locally without exchanging data between nodes.

SQL Server SQL, our source dialect, does not allow for these
optimizations, so we've introduced the notion of hints. In the following
example, a hint is provided on which field should be used for the
distribution of data across nodes:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{--HINT DISTRIBUTE_ON_KEY(person_id)}
\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{INTO}\NormalTok{ one_table }\KeywordTok{FROM}\NormalTok{ other_table;}
\end{Highlighting}
\end{Shaded}

which will translate into the following on PDW:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{--HINT DISTRIBUTE_ON_KEY(person_id)}
\ControlFlowTok{IF}\NormalTok{ XACT_STATE() }\OperatorTok{=} \DecValTok{1} \KeywordTok{COMMIT}\NormalTok{; }
\KeywordTok{CREATE} \KeywordTok{TABLE}\NormalTok{ one_table }\KeywordTok{WITH}\NormalTok{ (DISTRIBUTION }\OperatorTok{=} \KeywordTok{HASH}\NormalTok{(person_id)) }\KeywordTok{AS}
\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM}\NormalTok{ other_table;}
\end{Highlighting}
\end{Shaded}

Another tuning parameter is the key to sort a table on. This can be also
be specified in a hint:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{--HINT SORT_ON_KEY(INTERLEAVED:start_date)}
\KeywordTok{CREATE} \KeywordTok{TABLE}\NormalTok{ cdm.my_table (row_id }\DataTypeTok{INT}\NormalTok{, start_date);}
\end{Highlighting}
\end{Shaded}

translates to the following on RedShift:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{--HINT SORT_ON_KEY(INTERLEAVED:start_date)}
\KeywordTok{CREATE} \KeywordTok{TABLE}\NormalTok{ cdm.my_table (row_id }\DataTypeTok{INT}\NormalTok{, start_date)}
\NormalTok{INTERLEAVED SORTKEY(start_date);}
\end{Highlighting}
\end{Shaded}

The hints should be formatted exactly as shown above, and directly
precede the statement where the table is created.

\hypertarget{debugging-parameterized-sql}{%
\section{Debugging parameterized
SQL}\label{debugging-parameterized-sql}}

Debugging parameterized SQL can be a bit complicated; Only the rendered
SQL can be tested against a database server, but changes to the code
should be made in the parameterized (pre-rendered) SQL.

A Shiny app is included in the SqlRender package for interactively
editing source SQL and generating rendered and translated SQL. The app
can be started using:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{launchSqlRenderDeveloper}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Which will open the default browser with the app.

In addition, two functions have been developed to aid the debugging
process: \texttt{renderFile()} and \texttt{translateFile()}. These can
be used to read SQL from file, render or translate it, and write it back
to file. For example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{translateFile}\NormalTok{(}\StringTok{"parameterizedSql.txt"}\NormalTok{, }\StringTok{"renderedSql.txt"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

will render the file, using the default parameter values specified in
the SQL. What works well for us is editing in the parameterized file,
(re)running the command above, and have the rendered SQL file open in a
SQL client for testing. Any problems reported by the server can be dealt
with in the source SQL, and can quickly be re-rendered.

\hypertarget{developing-r-packages-that-contain-parameterized-sql}{%
\section{Developing R packages that contain parameterized
SQL}\label{developing-r-packages-that-contain-parameterized-sql}}

Often, the SQL code will become part of an R package, where it might be
used to perform initial data-preprocessing and extraction before further
analysis. We've developed the following practice for doing so: The
parameterized SQL should be located in the \emph{inst/sql/} folder of
the package. The parameterized SQL for SQL Server should be in the
\emph{inst/sql/sql\_server/} folder. If for some reason you do not want
to use the translation functions to generate the SQL for some dialect
(e.g because dialect specific code might be written that gives better
performance), a dialect-specific version of the parameterized SQL should
be placed in a folder with the name of that dialect, for example
\emph{inst/sql/oracle/}. SqlRender has a function
\texttt{loadRenderTranslateSql()} that will first check if a
dialect-specific version is available for the target dialect. If it is,
that version will be rendered, else the SQL Server version will be
rendered and subsequently translated to the target dialect.

The \texttt{createRWrapperForSql()} function can be used to create an R
wrapper around a rendered SQL file, using the
\texttt{loadRenderTranslateSql()} function . For example, suppose we
have a text file called \emph{test.sql} containing the following
parameterized SQL:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\{}\KeywordTok{DEFAULT}\NormalTok{ @selected_value }\OperatorTok{=} \DecValTok{1}\NormalTok{\}}
\KeywordTok{SELECT} \OperatorTok{*} \KeywordTok{FROM} \KeywordTok{table} \KeywordTok{INTO}\NormalTok{ result }\KeywordTok{where}\NormalTok{ x }\OperatorTok{=}\NormalTok{ @selected_value;}
\end{Highlighting}
\end{Shaded}

Then the command

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{createRWrapperForSql}\NormalTok{(}\DataTypeTok{sqlFilename =} \StringTok{"test.sql"}\NormalTok{, }
                     \DataTypeTok{rFilename =} \StringTok{"test.R"}\NormalTok{, }
                     \DataTypeTok{packageName =} \StringTok{"myPackage"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

would result in the file \emph{test.R} being generated containing this R
code:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#' Todo: add title}
\CommentTok{#'}
\CommentTok{#' @description}
\CommentTok{#' Todo: add description}
\CommentTok{#'}
\CommentTok{#' @details}
\CommentTok{#' Todo: add details}
\CommentTok{#'}
\CommentTok{#' @param connectionDetails   An R object of type \textbackslash{}code\{ConnectionDetails\} created ...}
\CommentTok{#' @param selectedValue}
\CommentTok{#'}
\CommentTok{#' @export}
\NormalTok{test <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(connectionDetails, }\DataTypeTok{selectedValue =} \DecValTok{1}\NormalTok{) \{}
\NormalTok{    renderedSql <-}\StringTok{ }\KeywordTok{loadRenderTranslateSql}\NormalTok{(}\StringTok{"test.txt"}\NormalTok{, }\DataTypeTok{packageName =} \StringTok{"myPackage"}\NormalTok{, }\DataTypeTok{dbms =}\NormalTok{ connectionDetails}\OperatorTok{$}\NormalTok{dbms, }\DataTypeTok{selected_value =}\NormalTok{ selectedValue)}
\NormalTok{    conn <-}\StringTok{ }\KeywordTok{connect}\NormalTok{(connectionDetails)}
    
    \KeywordTok{writeLines}\NormalTok{(}\StringTok{"Executing multiple queries. This could take a while"}\NormalTok{)}
    \KeywordTok{executeSql}\NormalTok{(conn, renderedSql)}
    \KeywordTok{writeLines}\NormalTok{(}\StringTok{"Done"}\NormalTok{)}
    
\NormalTok{    dummy <-}\StringTok{ }\KeywordTok{dbDisconnect}\NormalTok{(conn)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This code expects the file \emph{test.sql} to be located in the
\emph{inst/sql/sql\_server/} folder of the package source.

Note that the parameters are identified by the declaration of default
values, and that snake\_case names (our standard for SQL) are converted
to camelCase names (our standard for R).

\end{document}
